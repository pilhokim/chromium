diff --git a/chrome/browser/process_singleton_mac.cc b/chrome/browser/process_singleton_mac.cc
index ae234d6..a491ecd 100644
--- a/chrome/browser/process_singleton_mac.cc
+++ b/chrome/browser/process_singleton_mac.cc
@@ -36,7 +36,7 @@
 // process will be considered as hung for some reason. The second process then
 // retrieves the process id from the symbol link and kills it by sending
 // SIGKILL. Then the second process starts as normal.
-
+#define MAC_APP_STORE
 #include "chrome/browser/process_singleton.h"
 
 #include <errno.h>
@@ -898,14 +898,19 @@ bool ProcessSingleton::Create() {
     return false;
   }
   // Setup the socket symlink and the two cookies.
+#ifndef MAC_APP_STORE
   base::FilePath socket_target_path =
       socket_dir_.path().Append(chrome::kSingletonSocketFilename);
+#endif
   base::FilePath cookie(GenerateCookie());
   base::FilePath remote_cookie_path =
       socket_dir_.path().Append(chrome::kSingletonCookieFilename);
   UnlinkPath(socket_path_);
   UnlinkPath(cookie_path_);
-  if (!SymlinkPath(socket_target_path, socket_path_) ||
+  if (
+#ifndef MAC_APP_STORE
+			!SymlinkPath(socket_target_path, socket_path_) ||
+#endif
       !SymlinkPath(cookie, cookie_path_) ||
       !SymlinkPath(cookie, remote_cookie_path)) {
     // We've already locked things, so we can't have lost the startup race,
@@ -916,10 +921,18 @@ bool ProcessSingleton::Create() {
     return false;
   }
 
-  SetupSocket(socket_target_path.value(), &sock, &addr);
+#ifndef MAC_APP_STORE
+	SetupSocket(socket_target_path.value(), &sock, &addr);
+#else
+	SetupSocket(socket_path_.value(), &sock, &addr);
+#endif
 
   if (bind(sock, reinterpret_cast<sockaddr*>(&addr), sizeof(addr)) < 0) {
+#ifndef MAC_APP_STORE
     PLOG(ERROR) << "Failed to bind() " << socket_target_path.value();
+#else
+    PLOG(ERROR) << "Failed to bind() " << socket_path_.value();
+#endif
     CloseSocket(sock);
     return false;
   }
diff --git a/chrome/common/chrome_constants.cc b/chrome/common/chrome_constants.cc
index c9a5a51..8e68cc0 100644
--- a/chrome/common/chrome_constants.cc
+++ b/chrome/common/chrome_constants.cc
@@ -8,6 +8,8 @@
 
 #define FPL FILE_PATH_LITERAL
 
+#define MAC_APP_STORE
+
 #if defined(OS_MACOSX)
 #define CHROMIUM_PRODUCT_STRING "Chromium"
 #if defined(GOOGLE_CHROME_BUILD)
@@ -186,8 +188,18 @@ const base::FilePath::CharType kShortcutsDatabaseName[] = FPL("Shortcuts");
 const base::FilePath::CharType kSingletonCookieFilename[] =
     FPL("SingletonCookie");
 const base::FilePath::CharType kSingletonLockFilename[] = FPL("SingletonLock");
+#ifdef MAC_APP_STORE
+// Used to be SingletonSocket but due to length limits of sockets we must peal this down.
+// See: https://code.google.com/p/chromium/issues/detail?id=33097 this is a temporary
+// work around.
+//
+// See: https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man4/unix.4.html
 const base::FilePath::CharType kSingletonSocketFilename[] =
-    FPL("SingletonSocket");
+    FPL("S");
+#else
+const base::FilePath::CharType kSingletonSocketFilename[] =
+      FPL("SingletonSocket");
+#endif
 const base::FilePath::CharType kSyncCredentialsFilename[] =
     FPL("Sync Credentials");
 const base::FilePath::CharType kThemePackFilename[] = FPL("Cached Theme.pak");
diff --git a/content/browser/accessibility/browser_accessibility_cocoa.mm b/content/browser/accessibility/browser_accessibility_cocoa.mm
index be9ff5b..5711cd8 100644
--- a/content/browser/accessibility/browser_accessibility_cocoa.mm
+++ b/content/browser/accessibility/browser_accessibility_cocoa.mm
@@ -17,10 +17,14 @@
 #include "content/public/common/content_client.h"
 #include "grit/webkit_strings.h"
 
+#define MAC_APP_STORE
+
+#ifndef MAC_APP_STORE
 // See http://openradar.appspot.com/9896491. This SPI has been tested on 10.5,
 // 10.6, and 10.7. It allows accessibility clients to observe events posted on
 // this object.
 extern "C" void NSAccessibilityUnregisterUniqueIdForUIElement(id element);
+#endif
 
 using content::AccessibilityNodeData;
 using content::BrowserAccessibility;
@@ -317,7 +321,9 @@ NSDictionary* attributeToMethodNameMap = nil;
 
 - (void)detach {
   if (browserAccessibility_) {
+#ifndef MAC_APP_STORE
     NSAccessibilityUnregisterUniqueIdForUIElement(self);
+#endif
     browserAccessibility_ = NULL;
   }
 }
diff --git a/content/browser/device_monitor_mac.mm b/content/browser/device_monitor_mac.mm
index e30cd5b..73aa157 100644
--- a/content/browser/device_monitor_mac.mm
+++ b/content/browser/device_monitor_mac.mm
@@ -4,7 +4,8 @@
 
 #include "content/browser/device_monitor_mac.h"
 
-#import <QTKit/QTKit.h>
+// #import <QTKit/QTKit.h>
+#import <Foundation/Foundation.h>
 
 #include "base/logging.h"
 
@@ -43,6 +44,7 @@ DeviceMonitorMac::QTMonitorImpl::QTMonitorImpl(DeviceMonitorMac* monitor)
 }
 
 void DeviceMonitorMac::QTMonitorImpl::Start() {
+/*
   NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
   device_arrival_ =
       [nc addObserverForName:QTCaptureDeviceWasConnectedNotification
@@ -64,9 +66,11 @@ void DeviceMonitorMac::QTMonitorImpl::Start() {
                        queue:nil
                   usingBlock:^(NSNotification* notification) {
                       OnAttributeChanged(notification);}];
+*/
 }
 
 void DeviceMonitorMac::QTMonitorImpl::Stop() {
+/*
   if (!monitor_)
     return;
 
@@ -74,16 +78,20 @@ void DeviceMonitorMac::QTMonitorImpl::Stop() {
   [nc removeObserver:device_arrival_];
   [nc removeObserver:device_removal_];
   [nc removeObserver:device_change_];
+*/
 }
 
 void DeviceMonitorMac::QTMonitorImpl::OnAttributeChanged(
     NSNotification* notification) {
+/*
   if ([[[notification userInfo] objectForKey:QTCaptureDeviceChangedAttributeKey]
           isEqualToString:QTCaptureDeviceSuspendedAttribute])
     OnDeviceChanged();
+*/
 }
 
 void DeviceMonitorMac::QTMonitorImpl::CountDevices() {
+/*
   NSArray* devices = [QTCaptureDevice inputDevices];
   number_video_devices_ = 0;
   number_audio_devices_ = 0;
@@ -99,9 +107,11 @@ void DeviceMonitorMac::QTMonitorImpl::CountDevices() {
         [device hasMediaType:QTMediaTypeMuxed])
       ++number_audio_devices_;
   }
+*/
 }
 
 void DeviceMonitorMac::QTMonitorImpl::OnDeviceChanged() {
+/*
   int number_video_devices = number_video_devices_;
   int number_audio_devices = number_audio_devices_;
   CountDevices();
@@ -111,21 +121,24 @@ void DeviceMonitorMac::QTMonitorImpl::OnDeviceChanged() {
 
   if (number_audio_devices_ != number_audio_devices)
     monitor_->NotifyDeviceChanged(base::SystemMonitor::DEVTYPE_AUDIO_CAPTURE);
+*/
 }
 
 DeviceMonitorMac::DeviceMonitorMac() {
+/*
   qt_monitor_.reset(new QTMonitorImpl(this));
   qt_monitor_->Start();
+*/
 }
 
 DeviceMonitorMac::~DeviceMonitorMac() {
-  qt_monitor_->Stop();
+//  qt_monitor_->Stop();
 }
 
 void DeviceMonitorMac::NotifyDeviceChanged(
     base::SystemMonitor::DeviceType type) {
   // TODO(xians): Remove the global variable for SystemMonitor.
-  base::SystemMonitor::Get()->ProcessDevicesChanged(type);
+//  base::SystemMonitor::Get()->ProcessDevicesChanged(type);
 }
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_widget_host_view_mac.mm b/content/browser/renderer_host/render_widget_host_view_mac.mm
index 71dfb16..9613644 100644
--- a/content/browser/renderer_host/render_widget_host_view_mac.mm
+++ b/content/browser/renderer_host/render_widget_host_view_mac.mm
@@ -3379,9 +3379,13 @@ static const NSTrackingRectTag kTrackingRectTag = 0xBADFACE;
 // Since this implementation doesn't have to wait any IPC calls, this doesn't
 // make any key-typing jank. --hbono 7/23/09
 //
+#define MAC_APP_STORE
+
+#ifndef MAC_APP_STORE
 extern "C" {
 extern NSString *NSTextInputReplacementRangeAttributeName;
 }
+#endif
 
 - (NSArray *)validAttributesForMarkedText {
   // This code is just copied from WebKit except renaming variables.
@@ -3390,8 +3394,10 @@ extern NSString *NSTextInputReplacementRangeAttributeName;
         NSUnderlineStyleAttributeName,
         NSUnderlineColorAttributeName,
         NSMarkedClauseSegmentAttributeName,
+#ifndef MAC_APP_STORE
         NSTextInputReplacementRangeAttributeName,
-        nil]);
+#endif
+				nil]);
   }
   return validAttributesForMarkedText_.get();
 }
diff --git a/content/renderer/renderer_main_platform_delegate_mac.mm b/content/renderer/renderer_main_platform_delegate_mac.mm
index b121144..2a87588 100644
--- a/content/renderer/renderer_main_platform_delegate_mac.mm
+++ b/content/renderer/renderer_main_platform_delegate_mac.mm
@@ -20,6 +20,9 @@
 #include "content/common/sandbox_init_mac.h"
 #include "third_party/mach_override/mach_override.h"
 
+#define MAC_APP_STORE
+
+#ifndef MAC_APP_STORE
 extern "C" {
 // SPI logging functions for CF that are exported externally.
 void CFLog(int32_t level, CFStringRef format, ...);
@@ -27,6 +30,7 @@ void _CFLogvEx(void* log_func, void* copy_desc_func,
     CFDictionaryRef format_options, int32_t level,
     CFStringRef format, va_list args);
 }  // extern "C"
+#endif
 
 namespace content {
 
@@ -64,7 +68,9 @@ void CrRendererCFLog(int32_t level, CFStringRef format, ...) {
 
   va_list args;
   va_start(args, format);
+#ifndef MAC_APP_STORE
   _CFLogvEx(NULL, NULL, NULL, level, format, args);
+#endif
   va_end(args);
 }
 
@@ -127,6 +133,7 @@ bool RendererMainPlatformDelegate::InitSandboxTests(bool no_sandbox) {
 }
 
 bool RendererMainPlatformDelegate::EnableSandbox() {
+#ifndef MAC_APP_STORE
   // rdar://9251340 http://openradar.me/9251340
   // See http://crbug.com/31225 and http://crbug.com/152566
   // To check if this is broken:
@@ -155,10 +162,10 @@ bool RendererMainPlatformDelegate::EnableSandbox() {
     err = mach_override_ptr((void*)&CFLog, (void*)&CrRendererCFLog, NULL);
     CHECK_EQ(err_none, err);
   }
-
+#endif
   // Enable the sandbox.
   bool sandbox_initialized = InitializeSandbox();
-
+#ifndef MAC_APP_STORE
   if (needs_ime_hack) {
     // After the sandbox is initialized, call into TIS. Doing this before
     // the sandbox is in place will open up renderer access to the
@@ -172,7 +179,7 @@ bool RendererMainPlatformDelegate::EnableSandbox() {
     g_text_input_services_source_list_ = CFArrayCreate(kCFAllocatorDefault,
         source_list, arraysize(source_list), &kCFTypeArrayCallBacks);
   }
-
+#endif
   return sandbox_initialized;
 }
 
diff --git a/media/media.gyp b/media/media.gyp
index d346dac4..bcdf216 100644
--- a/media/media.gyp
+++ b/media/media.gyp
@@ -401,8 +401,8 @@
         'video/capture/mac/platform_video_capturing_mac.h',
         'video/capture/mac/video_capture_device_mac.h',
         'video/capture/mac/video_capture_device_mac.mm',
-        'video/capture/mac/video_capture_device_qtkit_mac.h',
-        'video/capture/mac/video_capture_device_qtkit_mac.mm',
+        #'video/capture/mac/video_capture_device_qtkit_mac.h',
+        #'video/capture/mac/video_capture_device_qtkit_mac.mm',
         'video/capture/video_capture.h',
         'video/capture/video_capture_device.cc',
         'video/capture/video_capture_device.h',
@@ -725,7 +725,7 @@
               '$(SDKROOT)/System/Library/Frameworks/CoreMIDI.framework',
               '$(SDKROOT)/System/Library/Frameworks/CoreVideo.framework',
               '$(SDKROOT)/System/Library/Frameworks/OpenGL.framework',
-              '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
+              #'$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
         }],
diff --git a/media/video/capture/mac/video_capture_device_mac.h b/media/video/capture/mac/video_capture_device_mac.h
index adfd4c7..54834b4 100644
--- a/media/video/capture/mac/video_capture_device_mac.h
+++ b/media/video/capture/mac/video_capture_device_mac.h
@@ -18,7 +18,7 @@
 #include "media/video/capture/video_capture_device.h"
 #include "media/video/capture/video_capture_types.h"
 
-@protocol PlatformVideoCapturingMac;
+// @protocol PlatformVideoCapturingMac;
 
 namespace media {
 
@@ -74,7 +74,7 @@ class VideoCaptureDeviceMac : public VideoCaptureDevice {
   base::WeakPtrFactory<VideoCaptureDeviceMac> weak_factory_;
   base::WeakPtr<VideoCaptureDeviceMac> weak_this_;
 
-  id<PlatformVideoCapturingMac> capture_device_;
+  //id<PlatformVideoCapturingMac> capture_device_;
 
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceMac);
 };
diff --git a/media/video/capture/mac/video_capture_device_mac.mm b/media/video/capture/mac/video_capture_device_mac.mm
index 77d30e9..99ced68 100644
--- a/media/video/capture/mac/video_capture_device_mac.mm
+++ b/media/video/capture/mac/video_capture_device_mac.mm
@@ -9,7 +9,7 @@
 #include "base/logging.h"
 #include "base/time/time.h"
 #import "media/video/capture/mac/platform_video_capturing_mac.h"
-#include "media/video/capture/mac/video_capture_device_qtkit_mac.h"
+// #include "media/video/capture/mac/video_capture_device_qtkit_mac.h"
 
 namespace {
 
@@ -65,6 +65,7 @@ void GetBestMatchSupportedResolution(int* width, int* height) {
 namespace media {
 
 void VideoCaptureDevice::GetDeviceNames(Names* device_names) {
+/*
   // Loop through all available devices and add to |device_names|.
   device_names->clear();
 
@@ -74,6 +75,7 @@ void VideoCaptureDevice::GetDeviceNames(Names* device_names) {
               [key UTF8String]);
     device_names->push_back(name);
   }
+*/
 }
 
 // static
@@ -83,6 +85,7 @@ void VideoCaptureDevice::GetDeviceSupportedFormats(const Name& device,
 }
 
 const std::string VideoCaptureDevice::Name::GetModel() const {
+/*
   // Both PID and VID are 4 characters.
   if (unique_id_.size() < 2 * kVidPidSize) {
     return "";
@@ -95,9 +98,12 @@ const std::string VideoCaptureDevice::Name::GetModel() const {
   std::string id_product = unique_id_.substr(pid_location, kVidPidSize);
 
   return id_vendor + ":" + id_product;
+*/
+  return "";
 }
 
 VideoCaptureDevice* VideoCaptureDevice::Create(const Name& device_name) {
+/*
   VideoCaptureDeviceMac* capture_device =
       new VideoCaptureDeviceMac(device_name);
   if (!capture_device->Init()) {
@@ -106,6 +112,8 @@ VideoCaptureDevice* VideoCaptureDevice::Create(const Name& device_name) {
     capture_device = NULL;
   }
   return capture_device;
+*/
+  return NULL;
 }
 
 VideoCaptureDeviceMac::VideoCaptureDeviceMac(const Name& device_name)
@@ -115,18 +123,20 @@ VideoCaptureDeviceMac::VideoCaptureDeviceMac(const Name& device_name)
       loop_proxy_(base::MessageLoopProxy::current()),
       state_(kNotInitialized),
       weak_factory_(this),
-      weak_this_(weak_factory_.GetWeakPtr()),
-      capture_device_(nil) {
+      weak_this_(weak_factory_.GetWeakPtr()) //,
+      //capture_device_(nil) {
+     {
 }
 
 VideoCaptureDeviceMac::~VideoCaptureDeviceMac() {
-  DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
-  [capture_device_ release];
+//  DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
+//  [capture_device_ release];
 }
 
 void VideoCaptureDeviceMac::AllocateAndStart(
     const VideoCaptureCapability& capture_format,
     scoped_ptr<VideoCaptureDevice::Client> client) {
+/*
   DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
   if (state_ != kIdle) {
     return;
@@ -181,9 +191,11 @@ void VideoCaptureDeviceMac::AllocateAndStart(
   }
 
   state_ = kCapturing;
+*/
 }
 
 void VideoCaptureDeviceMac::StopAndDeAllocate() {
+/*
   DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
   DCHECK(state_ == kCapturing || state_ == kError) << state_;
   [capture_device_ stopCapture];
@@ -193,9 +205,11 @@ void VideoCaptureDeviceMac::StopAndDeAllocate() {
   client_.reset();
   state_ = kIdle;
   tried_to_square_pixels_ = false;
+*/
 }
 
 bool VideoCaptureDeviceMac::Init() {
+/*
   DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
   DCHECK_EQ(state_, kNotInitialized);
 
@@ -212,6 +226,8 @@ bool VideoCaptureDeviceMac::Init() {
 
   state_ = kIdle;
   return true;
+*/
+  return false;
 }
 
 void VideoCaptureDeviceMac::ReceiveFrame(
@@ -220,6 +236,7 @@ void VideoCaptureDeviceMac::ReceiveFrame(
     const VideoCaptureCapability& frame_info,
     int aspect_numerator,
     int aspect_denominator) {
+/*
   // This method is safe to call from a device capture thread,
   // i.e. any thread controlled by QTKit.
 
@@ -291,22 +308,24 @@ void VideoCaptureDeviceMac::ReceiveFrame(
 
   client_->OnIncomingCapturedFrame(
       video_frame, video_frame_length, base::Time::Now(), 0, false, false);
+*/
 }
 
 void VideoCaptureDeviceMac::ReceiveError(const std::string& reason) {
-  loop_proxy_->PostTask(FROM_HERE,
-      base::Bind(&VideoCaptureDeviceMac::SetErrorState, weak_this_,
-          reason));
+//  loop_proxy_->PostTask(FROM_HERE,
+//      base::Bind(&VideoCaptureDeviceMac::SetErrorState, weak_this_,
+//          reason));
 }
 
 void VideoCaptureDeviceMac::SetErrorState(const std::string& reason) {
-  DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
-  DLOG(ERROR) << reason;
-  state_ = kError;
-  client_->OnError();
+//  DCHECK_EQ(loop_proxy_, base::MessageLoopProxy::current());
+//  DLOG(ERROR) << reason;
+//  state_ = kError;
+//  client_->OnError();
 }
 
 bool VideoCaptureDeviceMac::UpdateCaptureResolution() {
+/*
  if (![capture_device_ setCaptureHeight:current_settings_.height
                                   width:current_settings_.width
                               frameRate:current_settings_.frame_rate]) {
@@ -314,6 +333,8 @@ bool VideoCaptureDeviceMac::UpdateCaptureResolution() {
    return false;
  }
  return true;
+*/
+ return false;
 }
 
 } // namespace media
diff --git a/net/dns/dns_config_service_posix.cc b/net/dns/dns_config_service_posix.cc
index baf9172..adbeec5 100644
--- a/net/dns/dns_config_service_posix.cc
+++ b/net/dns/dns_config_service_posix.cc
@@ -121,10 +121,17 @@ class ConfigWatcher {
   typedef base::Callback<void(bool succeeded)> CallbackType;
 
   bool Watch(const CallbackType& callback) {
+#if 0
+		// this is disabled for acceptance to the mac app store,
+		// entitlements do not allow atching sensitive file system
+		// data in /etc/
     callback_ = callback;
     return watcher_.Watch(base::FilePath(kFilePathConfig), false,
                           base::Bind(&ConfigWatcher::OnCallback,
                                      base::Unretained(this)));
+#else
+		return false;
+#endif
   }
 
  private:
@@ -214,6 +221,10 @@ class DnsConfigServicePosix::Watcher {
                                 DNS_CONFIG_WATCH_FAILED_TO_START_CONFIG,
                                 DNS_CONFIG_WATCH_MAX);
     }
+#if 0
+		// this is disabled for acceptance to the mac app store,
+		// entitlements do not allow watching sensitive file system
+		// data in /etc/
     if (!hosts_watcher_.Watch(base::FilePath(kFilePathHosts), false,
                               base::Bind(&Watcher::OnHostsChanged,
                                          base::Unretained(this)))) {
@@ -223,6 +234,7 @@ class DnsConfigServicePosix::Watcher {
                                 DNS_CONFIG_WATCH_FAILED_TO_START_HOSTS,
                                 DNS_CONFIG_WATCH_MAX);
     }
+#endif
     return success;
   }
 
diff --git a/ui/shell_dialogs/select_file_dialog_mac.mm b/ui/shell_dialogs/select_file_dialog_mac.mm
index dcbc93f..992ecc2 100644
--- a/ui/shell_dialogs/select_file_dialog_mac.mm
+++ b/ui/shell_dialogs/select_file_dialog_mac.mm
@@ -24,6 +24,8 @@
 #import "ui/base/cocoa/nib_loading.h"
 #include "ui/base/l10n/l10n_util_mac.h"
 
+#define MAC_APP_STORE
+
 namespace {
 
 const int kFileTypePopupTag = 1234;
@@ -403,7 +405,9 @@ bool SelectFileDialogImpl::HasMultipleFileTypeChoicesImpl() {
         index = 1;
       }
     } else {
+#ifndef MAC_APP_STORE
       CHECK([panel isKindOfClass:[NSOpenPanel class]]);
+#endif
       NSArray* urls = [static_cast<NSOpenPanel*>(panel) URLs];
       for (NSURL* url in urls)
         if ([url isFileURL])
